#!/usr/bin/python3

from termcolor import colored
import inspect
from smart_env import ENV as env
from bash import bash
from python_shell import Shell as sh  # TODO remove it
import sys
import os

def red(text):
    return colored(text, "red")

def grey(text):
    return colored(text, 'white', attrs=['dark'])

def get_name():
    return str(bash('basename $PWD'))

def ask_for_confirmation(prompt, preferred):  # TODO to library
    if preferred:
        return input(prompt + " [Y/n] ") not in ("N", "n")
    return input(prompt + "[y/N] ") in ("Y", "y")

def find_all(text, substring):
    for i, line in enumerate(text.split('\n')):
        j = -1
        while True:
            j = line.find(substring, j + 1)
            if j == -1:
                break
            yield i, j

class library_factory:
    def __call__(self, action, *args):
        self.working_directory = str(bash('git rev-parse --show-toplevel'))
        os.chdir(self.working_directory)

        # try:
        getattr(self, action, self.help)(*args)
        # except TypeError:
        #     self.help()

    def help(self, *args):
        """displays help message"""

        print("Usage:", red(sys.argv[0]), "<action> [args]")
        print("Actions:")

        for action in dir(self):
            if action.startswith("_") or not callable(getattr(self, action)): continue
            print("- {}{} - {}".format(
                red(action),
                inspect.signature(getattr(self, action)), 
                getattr(self, action).__doc__
            ))

    def launch(self):
        """launches current game"""
        print("Launching", red(get_name()))
        exit(sh.love(".").return_code)

    def commit(self, *text):
        """adds, commits & pushes"""
        sh.git("add", ".")
        sh.git("commit", "-m", " ".join(text))
        sh.git("push", "origin", "master")

    def test(self):
        """launches engine & game tests"""
        print("Starting", red("EROS"), "tests via", red("busted"))
        result1 = sh.love(".", "selftest").return_code

        print("Starting", red(get_name()), "tests via", red("busted"))
        result1 = sh.love(".", "test").return_code

        if result1 + result2:
            exit(1)

    def build(self):
        """creates Windows executable"""
        print("Starting", red(get_name()), "build")

        sh.mkdir("-p", "bin/build")

        print("Creating love file")

        love = f"bin/build/{get_name()}.love"
        sh.zip("-9", "-r", love, ".", "-q")

        print("Creating exe file")

        sh.cat("eros/bin/love.exe", love, ">", f"bin/{get_name()}.exe")
        sh.rm("-r", "bin/build")

        print("Creating final zip archive")

        zip_ = f"bin/{get_name()}.zip"
        sh.rm("-rf", zip_)
        sh.zip("-9", "-r", zip_, "bin", "-q")

        print("Build finished!")

    def mv(self, from_, to):
        """renames reference"""
        for filepath in str(bash(f'find . -name "*.lua" -print0 | xargs -0 ls')).split():
            filepath = filepath[2:]

            content = str(bash('cat ' + filepath))
            
            concurrences = tuple(find_all(content, from_))
            if concurrences:
                print("File", red(filepath), "\n")

            for i, j in concurrences:
                lines = content.split("\n")

                if i > 0:
                    print(grey(f"{i}:"), lines[i - 1])

                print(
                    grey(f"{i + 1}: "), 
                    lines[i][:j], 
                    red(lines[i][j:j + len(from_)]), 
                    lines[i][j + len(from_):],
                    sep=""
                )

                if i < len(lines) - 1:
                    print(grey(f"{i + 2}: ") + lines[i + 1])

                print()

                if ask_for_confirmation(f"Replace it with \"{to}\"?", True):
                    lines[i] = lines[i][:j] + to + lines[i][j + len(from_):]
                    content = "\n".join(lines)

            with open(filepath, 'w') as f:
                f.write(content)

            if concurrences:
                print()

    def stat(self):
        print("project", red(get_name()))
        print(red("Lines:"), bash("( find ./ -name '*.lua' -print0 | xargs -0 cat ) | wc -l"))
        print(red("Words:"), bash("( find ./ -name '*.lua' -print0 | xargs -0 cat ) | wc -w"))
        print(red("Chars:"), bash("( find ./ -name '*.lua' -print0 | xargs -0 cat ) | wc -m"))

if __name__ == '__main__':
    library_factory()(*sys.argv[1:])
    exit(0)
