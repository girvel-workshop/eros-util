#!/usr/bin/python3

from termcolor import colored
import inspect
from smart_env import ENV as env
from bash import bash
from python_shell import Shell as sh  # TODO remove it
import sys
import os

def red(text):
    return colored(text, "red")

def grey(text):
    return colored(text, 'white', attrs=['dark'])

def get_name():
    return str(bash('basename $(git rev-parse --show-toplevel)'))

def ask_for_confirmation(prompt, preferred):  # TODO to library
    if preferred:
        return input(prompt + " [Y/n] ") not in ("N", "n")
    return input(prompt + "[y/N] ") in ("Y", "y")

def find_all(text, substring):
    for i, line in enumerate(text.split('\n')):
        j = -1
        while True:
            j = line.find(substring, j + 1)
            if j == -1:
                break
            yield i, j

class library_factory:
    def __call__(self, action, *args):
        self.working_directory = str(bash('git rev-parse --show-toplevel'))
        os.chdir(self.working_directory)

        # try:
        getattr(self, action, self.help)(*args)
        # except TypeError:
        #     self.help()

    def help(self, *args):
        """displays help message"""

        print("Usage:", red(sys.argv[0]), "<action> [args]")
        print("Actions:")

        for action in dir(self):
            if action.startswith("_") or not callable(getattr(self, action)): continue
            print("- {}{} - {}".format(
                red(action),
                inspect.signature(getattr(self, action)), 
                getattr(self, action).__doc__
            ))

    def launch(self, *options):
        """launches current game"""
        print("Launching", red(get_name()))
        os.system("love . " + " ".join(repr(o) for o in options))

    def commit(self, *text):
        """adds, commits & pushes"""
        sh.git("add", ".")
        sh.git("commit", "-m", " ".join(text))
        sh.git("push", "origin", "master")

    def test(self, *options):
        """launches engine & game tests"""
        print("Starting", red("EROS"), "tests")
        os.system("love . selftest " + " ".join(repr(o) for o in options))

    def build(self):
        """creates Windows executable"""
        name = get_name()
        print("Starting", red(get_name()), "build")

        os.system("mkdir source")
        os.system("cp -r ./* source")
        os.chdir("source")
        os.system(
            "rm -rf documentation bin .git .gitignore README.md "
            "war-routine.sublime-* eros/bin source build"
            "*.exe *.love *.zip"
        )

        os.system("mkdir ../build")

        print("Creating love file")

        os.system(f"zip -9 -r ../build/{name}.love . -q")
        os.chdir("..")

        print("Creating exe file")

        os.system(f"cat eros/bin/love.exe build/{name}.love > bin/{name}.exe")

        print("Creating final zip archive")

        os.system(f"rm -rf {name}.zip")
        os.system(f"zip -9 -r {name}.zip bin -q")

        print("Removing temp files")

        os.system("rm -rf source")
        os.system("rm -rf build")

        print("Build finished!")

        # sh.mkdir("-p", "bin/source")
        # os.system("cp -r ./* bin/source/")

        # os.chdir("bin/source")
        # os.system(
        #     "rm -rf documentation bin .git .gitignore README.md "
        #     "war-routine.sublime-* eros/bin"
        # )

        # os.system("mkdir -p bin/build")

        # print("Creating love file")

        # love = f"bin/build/{get_name()}.love"
        # os.system(f"zip -9 -r {love} bin/source/ -q")
        # os.chdir("..")

        # print("Creating exe file")

        # sh.cat("eros/bin/love.exe", love, ">", f"bin/{get_name()}.exe")
        # sh.rm("-r", "bin/build")

        # print("Creating final zip archive")

        # zip_ = f"bin/{get_name()}.zip"
        # sh.rm("-rf", zip_)
        # sh.zip("-9", "-r", zip_, "bin", "-q")

        # print("Build finished!")

    def mv(self, from_, to):
        """renames reference"""
        for filepath in str(bash(f'find . -name "*.lua" -print0 | xargs -0 ls')).split():
            filepath = filepath[2:]

            content = str(bash('cat ' + filepath))
            
            concurrences = tuple(find_all(content, from_))
            if concurrences:
                print("File", red(filepath), "\n")

            for i, j in concurrences:
                lines = content.split("\n")

                if i > 0:
                    print(grey(f"{i}:"), lines[i - 1])

                print(
                    grey(f"{i + 1}: "), 
                    lines[i][:j], 
                    red(lines[i][j:j + len(from_)]), 
                    lines[i][j + len(from_):],
                    sep=""
                )

                if i < len(lines) - 1:
                    print(grey(f"{i + 2}: ") + lines[i + 1])

                print()

                if ask_for_confirmation(f"Replace it with \"{to}\"?", True):
                    lines[i] = lines[i][:j] + to + lines[i][j + len(from_):]
                    content = "\n".join(lines)

            with open(filepath, 'w') as f:
                f.write(content)

            if concurrences:
                print()

    def stat(self):
        print("project", red(get_name()))
        print(red("Lines:"), bash("( find ./ -name '*.lua' -print0 | xargs -0 cat ) | wc -l"))
        print(red("Words:"), bash("( find ./ -name '*.lua' -print0 | xargs -0 cat ) | wc -w"))
        print(red("Chars:"), bash("( find ./ -name '*.lua' -print0 | xargs -0 cat ) | wc -m"))

if __name__ == '__main__':
    library_factory()(*sys.argv[1:])
    exit(0)
